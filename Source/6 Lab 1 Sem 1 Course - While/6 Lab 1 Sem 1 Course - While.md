<p align='center'>
    Центральноукраїнський національний технічний унiверситет<br>
    Кафедра програмування комп’ютерних систем і мереж<br>
    Дисципліна: Базові технології та методології програмування<br><br><br>
</p>
<p align='center'>
    Звiт<br>
    з лабораторної роботи №6<br>
    Тема: Програмна обробка алгоритмічних конструкцій циклічної структури<br><br>
    Мета роботи: Навчитись складати алгоритми розв’язку задач, які вміщують циклічний обчислювальний процес, та програми для їх реалізації; отримати навики у визначенні та використанні оператора цикла; ознайомитися з ітераційними процесами.<br><br><br>
</p>
<p align='right'>
    Виконав: ст. гр. КМ-20<br>
    Калиновський В.М.<br>
    Перевірила: асистент кафедри ПКСМ<br>
    Тесленко О.Є.<br>
    Варіант 3<br><br><br>
</p>
<p align='left'>
    Дата виконання: 30.10.2020<br>
    Дата оформлення: 03.11.2020<br><br>
</p>
<p align='center'>
    Кропивницький 2020 р.<br>
</p>

### Завдання

1. Формалізувати зміст задачі, скласти блок-схему алгоритму та програму обома мовами для обчислення на ЕОМ таблиці значень функції вигляду F(x) на інтервалі [a, b] з кроком h = (b - a) / m, де m – задане ціле число; там, де потрібно, врахувати область визначення функції; розробити два варіанти програми: перший – значення змінної в точка розраховується за формулою x_i = a + i * h, скористатись циклом з параметром та вивести дані у формі «Для x[1]=<значення>: функція y[1]=<значення>»; другий – значення змінної в точка розраховується за формулою x = x + h, скористатись циклом з передумовою та вивести у форматі таблиці, де X та Y записані у заголовку таблиці, а отриманні значення роздрукувати нижче, відповідно, під ними; за третім варіантом дана функція F(x) = x - 2 + sin⁡(1/2), інтервал від 1,2 до 2 та кількість точок – 10;
2. Скласти блок-схему алгоритму та програму, яка обчислює функцію, розкладену в ряд Маклорена з заданою точністю; на друк вивести: функцію, її значення при розкладанні функції в ряд Маклорена, кількість елементів, які врахувались при розрахунках для досягнення заданої точності; зробити перевірку рішення; за третім варіантом дана функція F(x) = cos18 та точність 10^(-6)

### Робота

Після ознайомлення із завданням я складаю алгоритм для програми першого завдання:

1. Ввести значення початку (a), кінця (b) відрізка та кількість точок (m) на відрізці
2. Розрахувати шаг h за формулою h = (b - a) / m
3. Розрахувати значення X та Y залежно від шагу
4. Цикл повторюється, поки не буде проведено кількість розрахунків, що залежить від кількості точок
5. Вивести всі ці значення

Код першого варіанта оформлення на С написано у коді 1, другий у коді 2, перший на Паскалі у коді 3 та другий у коді 4. Результати виконання всіх програм зображено на рисунку 1.

Алгоритмом другої програми є:

1. Введення значення межі розрахунку (ξ) та значення функції F(x)
2. Введення значень Maklorcosiks, n, a_n
3. Розраховую ∑_(n = 1)^∞ a_n  за формулою a_n =(-1)^n * (x^2n / (2n)!)
4. Цикл повторюється, поки a_n ≥ ξ
5. Після виводиться результат розрахунку

Код другої програми, написаної на С виведено у коді 5, а на мові Паскаль у коді 6, результати виконання програм виведено на рисунку 2.

Код 1:
```cpp
#include <stdio.h>
#include <math.h>
#include <Windows.h>

void f(float x);
float y;

int main() {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	float a = 1.2; //Начало отрезка
	float b = 2; //Конец отрезка
	float m = 10; //Количество точек на отрезке
	float xi = a; //Выводимое число

	float h = (b - a) / m; //Определение шага отрезка

	float xy; //Нужна для вывода того же X значения, но для переменной Y

	int i = 1;
	for (i; i <= 10; i++) {
		xi = xi + h;
		xy = xi;
		f(xi);
		printf("Для X[%2i] = %4.2f: функция Y[%4.2f] = %4.3f\n", i, xi, xy, y);
	}
	system("pause");
	return 0;
}

void f(float x) {
	/*Так как с синусом программа отказывается раотать: при указании значения 1/2 вообще
	его не считает, а при указании 0.5 выдаёт совсем странные результаты, я сам расчитал
	значение sin(1/2) и подставил это готовое значение в формулу*/
	y = x - 2 + 0.008;
}
```

Код 2:
```cpp
#include <stdio.h>
#include <math.h>
#include <Windows.h>

void f(float x);
float y;

int main() {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	float a = 1.2; //Начало отрезка
	float b = 2; //Конец отрезка
	float m = 10; //Количество точек на отрезке
	float x = a; //Выводимое число

	float h = (b - a) / m; //Определение шага отрезка

	printf("|____X____|_____Y____|\n");

	int i = 1;
	while (i <= 10) {
		x = x + h;
		f(x);
		if (y < 0) {
			printf("|_ _ %5.3f _ _ | _ _ %5.3f _ _ |\n", x, y);
		}
		else {
			printf("| _ _ %5.3f _ _ | _ _ _ %5.3f _ _ |\n", x, y);
		}
		i++;
	}
	system("pause");
	return 0;
}

void f(float x) {
	/*Так как с синусом программа отказывается раотать: при указании значения 1/2 вообще
	его не считает, а при указании 0.5 выдаёт совсем странные результаты, я сам расчитал
	значение sin(1/2) и подставил это готовое значение в формулу*/
	y = x - 2 + 0.008;
}
```

Код 3:
```pascal
program Kalinka_Zad1Pasv1;
uses crt;
var a, b, m, xi, h, xy, y:real;
function f(x:real):real;
  begin
    y:=x-2+0.008;
  end;
begin
  a:=1.2;
  b:=2;
  m:=10;
  xi:=a;
  h:=(b-a)/m;
  for i:integer:=1 to 10 do
  begin
    xi:=xi+h;
    xy:=xi;
    f(xi);
    if (i<10) then writeln(' Для X[', i, '] = ', xi:4:2, ': функция Y[', xy:4:2, '] = ', y:5:3) else writeln('Для X[', i, '] = ', xi:4:2, ': функция Y[', xy:4:2, '] =  ', y:5:3);
  end;
  readkey;
end.
```

Код 4:
```pascal
program Kalinka_Zad1Pasv2;
uses crt;
var a, b, m, x, h, y:real; i:integer;
function f(x:real):real;
  begin
    y:=x-2+0.008;
  end;
begin
  a:=1.2;
  b:=2;
  m:=10;
  x:=a;
  h:=(b-a)/m;
  writeln('|____X____|_____Y____|');
  i:=1;
  while i<=10 do
    begin
    x:=x+h;
    f(x);
    if (y<0) then writeln('|__', x:5:3, '__|__', y:5:3, '__|') else writeln('|__', x:5:3, '__|___', y:5:3, '__|');
    i:=i+1;
    end;
  readkey;
end.
```

Рисунок 1:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n1.png"/>
</p>

Код 5:
```cpp
#include <stdio.h>
#include <math.h>
#include <Windows.h>

const float eps = 1E-6;
const float cosiks = cos(18);

int factorial(int n) { //Объявляю функцию, которая будет считать факториал
	if (n == 1) {
		return 1;
	}
	else {
		return n * factorial(n - 1);
	}
}

int main() {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	double Maklorcosiks = 1; //Здесь "Maklorcosiks" представляет собой косинус икса в ряде Маклорена
	int n = 0; //Количество элементов
	double an;

	do {
		n++; //Увеличиваю номер на единицу
		int n2 = 2 * n; //Вспомогательная переменная

		double oneinn = pow(-1, n); //Первое число - возвожу -1 в степень н
		double x2n = pow(cosiks, n2); //Второе число - возвожу икс в степень 2н
		int fact2n = factorial(n2); //Третье число - нахожу факториал числа 2н

		an = oneinn * (x2n / fact2n); //Подставил все три числа в формулу для нахождения a_n
		Maklorcosiks = Maklorcosiks + an; //Увеличиваю число "an" в "b" раз
		printf("%lf    %lf\n", Maklorcosiks, an); //Для проверка исправности программы
	} while (fabs(an) >= eps);

	/*Если нужно выполнять цикл до тех пор, пока он не станет меньше чего-то,
	значит он выполняется, пока он больше этого чего-то и стремится к нему (уменьшается),
	поэтому цикл выполняется пока an больше eps, и с каждым разом an становиться всё
	меньше, и когда an станет меньше eps - цикл закончится.*/

	printf("\nДля cos(18)[приблизительно =%.2f] при точности %e; %.2f = %lf при количестве элементов %i.\n\n", cosiks, eps, cosiks, Maklorcosiks, n);

	system("pause");
	return 0;
}
```

Код 6:
```pascal
program Kalinka_Zad1Pasv1;
uses crt;
var eps, cosiks, Maklorcosiks, an, oneinn, x2n, fact2n, n, n2, nprov, nprov1, nprov2, nprov3, nprov4:real;
function factorial(n:real):real;
  begin
    if (n=1) then factorial:=1 else factorial:=n*factorial(n-1);
  end;
begin
  eps:=1E-6;
  cosiks:=cos(18);
  Maklorcosiks:=1;
  n:=0;
  repeat
    n:=n+1;
    n2:=2*n;

    nprov:=n; nprov:=nprov/1; nprov1:=4; nprov2:=4; nprov3:=4; nprov4:=4;

    if nprov/1=1 then nprov1:=5;
    if nprov/2=1 then nprov2:=5;
    if nprov/3=1 then nprov3:=5;
    if nprov/4=1 then nprov4:=5;

    if nprov1=5 then oneinn:=-1;
    if nprov2=5 then oneinn:=1;
    if nprov3=5 then oneinn:=-1;
    if nprov4=5 then oneinn:=1;

    x2n:=exp(n2*ln(cosiks));
    fact2n:=factorial(n2);
    an:=oneinn*(x2n/fact2n);
    Maklorcosiks:=Maklorcosiks+an;
  until abs(an)<=eps;
  writeln;writeln('Для cos(18)[приблизительно =', cosiks:4:2, '] при точности ', eps ,'; ', cosiks:4:2, ' = ', Maklorcosiks, ' при количестве элементов ', n:2:0);
  readkey;
end.
```

Рисунок 2:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n2.png"/>
</p>

Перевірю роботу програми у калькуляторі: cos⁡ 18° ≈ 0.66. Мій ряд cos⁡(x) = 1-x^2/2! + x^2/2! - ... + (-1)^n * (x^2n/(2n)!) + ... =1 + ∑(n=1)^∞ (-1)^n * (x^2n/(2n)!), тому Maklorcosiks = 1, а a_n = (-1)^n * (x^2n/(2n)!). Оскільки S_n = S_(n-1) + a_n => 0.66 = 0.66_(n-1) + (-1)^n * (0.66^2n /(2n)!) => 0.66 ≈ 0.7899. Як ми бачимо, числа не зовсім зівпали, але такій похибці ми можемо дати причину погано сформульованого самого ряда. Можна вважати програму робочою.
Слід відмітити, чому погано так написана програма на Паскалі. Річ у тім, що на Паскалі не можна возводити ні до ніякої степені -1 , тому приходиться присвоювати мінус значенню a_n залежно від самого номера n. Знаючи, скільки елементів у ряді з програми на С, я зробив особисту перевірку для кожного номера. Тільки так можна заставити програму правильно порахувати значення.

### Контрольні питання

> Дані якого типу можна вживати як параметр циклу?

    integer

> Указати призначення та правила організації циклів у структурному програмуванні

    Цикли призначені для багаторазового використання однієї частини коду методом повторення. Повторення відбувається до тих пір, доки умова задовільняє значенню. Це значення і є параметром. Правилом організації циклу є обов’язкове зазначення параметрів у циклі. У разі їх невикористання цикл може бути або нескінченним або взагалі не працювати, в залежності від типа циклу

> Як працює цикл while?

    Він перевіряє умову й виконує цикл до тих пір, доки умова задовільняє виконання циклу

> Як працює цикл repeat?

    Він без перевірки починає виконання циклу й після першого виконання перевіряє умову й продовжується доти, доки параметр задовільняє умову. На відмінну від попереднього циклу, цей цикл виконується хоча б раз

> Вказати послідовність дій, які виконуються при організації циклічних розрахунків з указаною кількістю повторів?

    Ініціалізувати параметр, дати йому початкове значення, зазначити межу та зазначити шаг зміни лічильника

> Які обмеження накладаються на оператор циклу for?

    У ньому можна зазначити тільки можливу конкретну кількість повторів на відміну від попередніх двох типів циклів, які виконуються стільки разів, доки вони задовільняють умові

> Які оператори циклів використовуються для виконання повторювальних операцій в мові С?

    while; do – while; for

> Чим відрізняються цикли з передумовою та послідуючою умовою в мовах С та Паскаль?

    C:      передумова              while () {}
				    послідуюча умова        do {} while;
    Pascal: передумова              while <> begin .. end;
				    послідуюча умова        repeat begin .. end; until <> ;


> Який формат запису оператора for у мові C?

    for (лічильник; межа_лічильника; шаг_зміни_лічильника) {}

> Що таке вкладені цикли?

    Цикли, які викликаються та виконуються у циклі

> Як можна задати вічний цикл? Навести приклади

    Задати цикл for без передачі параметрів, або цикл while з передписаним параметром, який всередині циклу не змінюється, тому не може завершитися:
		* for (;;) {}
		* i = 1; do {printf(«Hello? World!»);} while (i <= 2);

> Написати код (завдання написано у самій лабораторній роботі) й дати відповідь

    Код програми написано у коді 7, а результат на рисунку 3
		Код 7:

```cpp
#include <stdio.h>

void main() {
    int S = 0;
	  int k;
	  int i;
	  for (i = 1; i <= 5; i++) {
		    k = 1 + i;
		    S = S + 2 * k;
	  }
	  printf("S = %i\n", S);
	  system("pause");
}
```

Рисунок 3:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n3.png"/>
</p>

> Написати код (завдання написано у самій лабораторній роботі) й дати відповідь

    Код першого циклу написано у коді 8, другого у 9, третього у 10, четвертого у 11, їх результати на рисунку 4
	Код 8:

```cpp
int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (x < 1.3) {
		x = x * x;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

	Код 9:

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (fabs(x) >= 1) {
		x--;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

	Код 10:

```cpp
#include <stdio.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);
	while (2 * x > x) {
		x--;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

	Код 11:

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (x * x >= 0) {
		x = sin(x)+1.315;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

Рисунок 4:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n4.png"/>
</p>

	Для кожного циклу по різному. Наприклад, для четвертого циклу незалежно від значення X він буде нескінченно зациклюватись; для першого циклу, якщо взяти значення більше 1.3 – він не починається, при значенні менше 1 – він буде нескінченним (як і четвертий), а при значенні між 1 та 1.3 – він майже відразу закінчується; другий та третій цикли працюють адекватно й рахують від заданого значення поступово до 1

> Написати код (завдання написано у самій лабораторній роботі) й дати відповідь

    Для розв’язання цієї задачі я написав три варіанти програми, які описані у кодах 12, 13, 14, а результат на рисунку 5
	Код 12:

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (fabs(x) + 1 > 0.793) {
		x++;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

	Код 13:

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (fabs(x) + 1 > 0.793) {
		x--;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

	Код 14:

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (fabs(x) + 1 > 0.793) {
		x--;
		x++;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

Рисунок 5:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n5.png"/>
</p>

	Як ми бачимо – ні. Так як у завданні не було зазначено, від чого залежить зміна параметра циклу, прийшлося писати три програми на всі три можливі випадки. Перший випадок – зміна X на 1 одиницю більше: цикл зациклюється з постійним збільшенням на одиницю; другий випадок - зміна X на 1 одиницю менше: цикл зациклюється з постійним зменшенням на одиницю; третій випадок - зміна X на 1 одиницю менше, а потім її збільшення: цикл зациклюється, виводячи тільки значення 5.000. Це відбувається, оскільки незалежно від заданого значення до нього додається одиниця – це число буде ЗАВЖДИ БІЛЬШЕ 1, а параметр порівнюється з числом, яке менше одиниці, тому цикл буде нескінченним

> Написати код (завдання написано у самій лабораторній роботі) й дати відповідь

    Код для розв’язку завдання написано у коді 15, а результат на рисунку 6
	Код 15:

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	float x;

	printf("X = ");
	scanf("%f", &x);

	while (fabs(x) + 1 > 0.793) {
		x--;
		x++;
		printf("\nX = %5.3f\n", x);
	}
	system("pause");
	return 0;
}
```

Рисунок 6:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n6.png"/>
</p>

	**ПОЯСНЕННЯ!** _Кожна строка виводиться тільки для перевірки працездатності програми._

> Написати код (завдання написано у самій лабораторній роботі) й дати відповідь

    Код для розв’язку завдання написано у коді 16, а результат на рисунку 7
	Код 16:

```cpp
#include <stdio.h>
#include <math.h>

double n;
double x;
int factorial(int n) {
	if (n == 1) {
		return 1;
	}
	else {
		return n * factorial(n - 1);
	}
}

int main() {
	double S = x;
	printf("N = ");
	scanf("%lf", &n);
	printf("X = ");
	scanf("%lf", &x);
	double an = x;
	printf("\n");
	for (n; n != 1; n--) {
		S = S + an;

		double xn = pow(x, n);
		int n1 = n - 1;
		int fact_n1 = factorial(n1);
		int fact_n = factorial(n);
		double x_n1 = pow(x, n1);

		double b = (xn * fact_n1) / (fact_n * x_n1);

		an = an * b;
	}
	S = S  + an + x;
	printf("S = %.16lf.\n", S);
	system("pause");
	return 0;
}
```

Рисунок 7:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n7.png"/>
</p>

	**ПОЯСНЕННЯ!** _При використанні цієї програми краще не користуватись великими числами!_

> Написати код (завдання написано у самій лабораторній роботі) й дати відповідь

    У завданні дано 2 фрагменти. Перший я відтворив у програмі таблиці 17, другий у таблиці 18, а їх результати на рисунку 8
	Код 17:

```cpp
#include <stdio.h>
#include <math.h>
#include <Windows.h>

void main() {
	int S = 0;
	int n = 1;
	int i;
	for (i = 1; i <= 3; i++) {
		int s = S + i;
		n = n * s;
		printf("S = %i\n", S);
	}
	system("pause");
}
```

	Код 18:

```cpp
#include <stdio.h>
#include <math.h>
#include <Windows.h>

void main() {
	int P = 1;
	int s = 2;
	int i;
	for (i = 1; i <= 4; i++) {
		P = P * 2 * i;
		int S = S + 3 * P;
		printf("S = %i\n", S);
	}
	system("pause");
}
```

Рисунок 8:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/6%20Lab%201%20Sem%201%20Course%20-%20While%20n8.png"/>
</p>

### Висновок

Ми навчились складати алгоритми розв’язку задач, які вміщують циклічний обчислювальний процес, та програми для їх реалізації; отримали навики у визначенні та використанні оператора цикла; ознайомилися з ітераційними процесами.

[Ссылка на методичку и готовые программы](https://drive.google.com/drive/folders/1ZAqsdXVCeG0btYKu5YDnS4GQkOydi2ZU?usp=sharing)
