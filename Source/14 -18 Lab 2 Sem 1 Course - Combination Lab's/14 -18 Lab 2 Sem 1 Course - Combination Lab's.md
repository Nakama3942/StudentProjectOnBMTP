<p align='center'>
    Центральноукраїнський національний технічний унiверситет<br>
    Кафедра програмування комп’ютерних систем і мереж<br>
    Дисципліна: Базові технології та методології програмування<br><br><br>
</p>
<p align='center'>
    Звiт<br>
    з лабораторної роботи №14–18<br>
    Тема: Вивчення технологій розв’язку задач з використанням циклів, одновимірних, двовимірних, динамічних масивів та вивчення технологій обробки текстових рядів<br><br>
    Мета роботи: Ознайомитись з операторами циклів, принципами формування одновимірних, двовимірних, динамічних масивів, вивчити способи виділення пам’яті для динамічних масивів, навчитись будувати математичну модель задачі, вивчити методи перевірки правильності вхідних даних, вивчити можливості оголошення та ініціалізації рядів, вивчити головні функції роботи з рядами, засвоїти використання головних функцій бібліотек та отримати практичні навики в написанні програм.<br><br><br>
</p>
<p align='right'>
    Виконав: ст. гр. КМ-20<br>
    Калиновський В.М.<br>
    Перевірила: доцент кафедри ПКСМ<br>
    Рибакова Л.В.<br>
    Варіант 3<br><br><br>
</p>
<p align='left'>
    Дата виконання: 28.03.2021 – 30.03.2021<br>
    Дата оформлення: 31.03.2021<br><br>
</p>
<p align='center'>
    Кропивницький 2020 р.<br>
</p>

### Завдання 1

Написати програму, що формує послідовність з парних An, кратних тринадцяти з діапазоном від 0 до 300, рахує суму цих самих елементів і виводить результат.

### Завдання 2

Написати програму, що шукає всі ПРОСТІ числа в діапазоні від 0 до 300 і виводить результат.

### Завдання 3

Написати програму, що шукає і виводить результат перших ненульових коренів a, b і c в рівнянні (a * b) - c^3 - 9 = 0 .

### Завдання 4

Написати програму, в якій за вибором користувача (вручну або програмно) заповнюється масив Mass[15] і підраховується кількість парних елементів масиву (результат виводиться).

### Завдання 5

Написати програму, що виконує запис значень елементів двовимірного масиву Mass[5][5] у послідовності, зазначеній на _Ілюстрації 1_, вивести результати читання і запису, значення матриці повинні бути в діапазоні від 1 до 25.

### Завдання 6

Написати програму для заповнення двовимірного масиву Mass[5][5] значеннями "0" і "1" у послідовності, зазначеній на _Ілюстрації 2_ та вивести результат.

### Завдання 7

Написати програму, котра має:

1. ДИНАМІЧНІ масиви;
2. У масиву максимальний розмір - N * M, де N і M - статичні константи;
3. У масиву реальний розмір - n * m (n <N, m <M) - вводяться користувачем;
4. Інтервал генерації елементів, який вказує користувач;
5. У масиву рандомно генерящіеся елементів;
6. На вході дані і елементи вхідного і вихідного масивів;
7. Висновок результату в красивому вигляді;
8. Функцію - зміна значень елементів масиву на значення відповідних елементів заданого одновимірного масиву.

### Завдання 8

Потрібно, щоб користувач вводив рядок тексту і програма виконувала наступне:

1. Вважає кількість різних слів, що є в заданому тексті
2. Виводить на екран кількість використаних символів
3. Видаляє всі слова, в яких є сдвленние літери

Іллюстрація 1:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n1.png"/>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n2.png"/>
</p>

### Робота

Я вирішив усі завдання написати в одній програмі. Кожен код програми буде представляти свій клас, а у головній функції будуть міститися тільки конструктори об’єктів й інколи виклики деяких методів класа. Кожен клас обрамлено своїми препроцессорами _#ifdef_ та _#endif_, а на початку  прописано _#define_. В залежності від того, що прописано у _#define_, компілятор буде вибирати тільки той блок коду, який обрамлено _#ifdef_ с такою ж назвою, та весь інший код, який не обрамлено іншими _#ifdef_. Напочатку опишемо, що можна прописати у _#define_, і що від цього буде скомпільовано. Після цього можна приступати до написання завдань.

_! Зауваження: всі схеми та алгоритми я буду описувати псевдокодом, а не блок-схемами, так як його швидше робити в декілька десятків разів, він менше місця займає і його набагато легше зрозуміти. Якщо потребується — я додам блок-схеми окремо, написаними від руки._

Для <u>завдання 1</u> розробилено наступну загальну структуру програми:

Крок 1: Перебирати елементи від 0 до 300;

Крок 2: Перевіряти кожен елемент: чи ділиться елемент на 2;

Крок 3: Перевіряти елементи, що ділиться на 2 на те, чи ділиться вони ще на 13;

Крок 4: Якщо так, то виводити їх на екран;

Крок 5: Додавати ці елементи до суми;

Крок 6: Коли дораховано до 300 — вивести суму;

Крок 7: Після виведення суми завершити програму.

_Що очікується від програми?_ Вона повинна відбирати тільки ті числа, що діляться на тринадцять (13, 26, 39, 52 ...), але не всі, а тільки ті, що ще є парними (26, 52, 78 ...), тобто першим має бути 26 і кожне наступне буде більше попереднбого на 26. Напишемо програму, що вибератиме всі парні числа, що діляться на 13. Результат:

<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n3.png"/>
</p>

_Результат:_ як бачимо, перші три числа співпали. Я власноруч перевіряв усі ці числа й вони реально діляться на 13 (що вони парні й так видно). Якщо перевіряти цих суму, елементів — вона дійсно має бути такою. _Вважаємо завдання виконаним! ✔ _

Для <u>завдання 2</u> написана загальна структура програми так:

Крок 1: Перебирати кожне число від 1 до 300;

Крок 2: Перевіряти кожне таке число, чи ділиться воно на ще якесь від 2 до 300;

Крок 3: Якщо ділиться, то скинути лічильник і почати з наступного числа;

Крок 4: Якщо інакше — продовжувати операцію далі;

Крок 5: Якщо перерахунок закінчився й число ніколи не поділилося — воно є простим й ділиться тільки на 1 й на себе;

Крок 6: Виводжу просте число;

Крок 7: Повторюю кроки 2 - 6 з наступними числами до 300;

Крок 8: Коли дораховано до 300 — завершити програму.

_! Пояснення:_ як саме зрозуміти на кроці 5, що число ділиться тільки на 1 і на саме себе? Відкрию секрет, але на один діляться всі числа, які існують (крім ноля, звісно ж), тому я його навіть не використовував у розрахунках для оптимізації програми, а починав з двох. При діленні на себе залишок від ділення дорівнює нулю, а у всіх інших випадках має залишатись тільки залишок від ділення — це я використовував при написанні програми. Якщо ж буде ще якесь число, на яке ділиться вибране націло, то залишок теж буде дорівнювати нолю — у цьому випадку виконується інструкція кроку 3. І якщо не виконається жодного разу інструкція за кроком три, це означатиме, що програма поділила вибране число націло тільки при діленні на себе. Це число ми і виводимо. Так перебираються всі числа.

Можна код класу програми переписати в окремий код, прописати _#define LIMIT_ __ (замість підкреслень вписати обмеження) й у циклі while прописати замість _“300” - “LIMIT”_. У цьому випадку програма буде рахувати прості числа не до 300 а до будь-якого числа, яке прописано у _#define_, хоч до трильйона (але не радиться це робити, оскільки програма це може робити довго — чим більше число, тим більше потрібно часу для розрахунку). Або просто спитати у користувача, до якого числа порахувати прості числа, записати відповідь у змінну й замінити у циклі _300_ або _LIMIT_ на цю змінну. Тоді програма буде рахувати до тих чисел, які задає користувач.

_Що очікується від програми?_ Потрібно отримати прості числа до 300 типу 1, 2, 3, 5, 7... Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n4.png"/>
</p>

_! Консоль у мене розширена, при зменшенні строки не перевиводяться, а при зменшенні і перевідкритті консоль знову стає широку. Скріншот я можу додати тільки такий._

_Результат:_ я власноруч перепровірив усі ці числа з таблицею простих чисел. Вони дійсно є всі у тій таблиці, а також на вивід не потрапляють ніякі зайві числа й жодного загубленого. _Вважаємо завдання виконаним! ✔ _

Для <u>завдання 3</u> написано таку загальну структуру програми:

Крок 1: Нехай найближчими до нуля будуть варіанти з числами до 10;

Крок 2: Перебираємо всі числа до 10:

Крок 2.1: Перебираємо число a до десяти;

Крок 2.2: Перебираємо число b до десяти;

Крок 2.3: Перебираємо число c до десяти;

Крок 2.4: Перебираємо число a з b до десяти;

Крок 2.5: Перебираємо число a з c до десяти;

Крок 2.6: Перебираємо число b з c до десяти;

Крок 2.7: Перебираємо число a з b з c до десяти;

Крок 3: Кожне з вибраних чисел перевіряємо по формулі (a * b) - c^3 - 9 = 0 ;

Крок 4: Якщо повертається true — вивести результат;

Крок 5: Після перебору всіх варіантів — завершити програму.

_Що очікується від програми?_ Насправді будуть перебиратись всі можливі комбінації для трьох чисел від 1 до 10. Для першого числа 10 варіацій, для другого 10 і для третього, а загальна кількість комбінацій 10 * 10 * 10 = 1000. Компьютер перебирає всю 1000 комбінацій і перевіряє кожну на те, чи буде ця комбінація у формулі дорівнювати 0. Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n5.png"/>
</p>

_Результат:_ отримано з 1000 комбінацій усього 3. Якщо підставити ці комбінації у формулу — вона дійсно буде дорівнювати 0. Власноруч перевіряти всі інші 997 варіацій у мене немає часу — будемо вважати, що програма рахує правильно. Щодо трьох результатів замість одного скажемо так: у кожно варіанта найменше число менше максимального іншого варіанта, тому вибрати найменший неможливо з цих трьох. Якщо вибирати по сумі елементів — перший найменший, але у нас не авторитарна система, тому у користувача має бути вибір — залишимо три варіанти. Якщо потрібно один — перевірку на суму можна написати у дві строчки й це може зробити кожний, а перевіряються уміння на знання операторів розгалужень з перших занять. _Тому будемо вважати завдання виконаним до кінця! ✔ _

Для <u>завдання 4</u> описано загальну структуру програми так:

Крок 1: Питаємо у користувача, як заповнити масив;

Крок 2: Якщо вибрано перший варіант — користувач власноруч вводить всі 15 елементів масива;

Крок 3: Якщо вибрано другий варіант — елементи масива генеруються рандомно;

Крок 4: Якщо відповідь введено неправильно — виводиться повідомлення про неправильну відповідь й обирається другий варіант;

Крок 5: Заповнення/генерація масива;

Крок 6: Для кожного елемента шукається пара;

Крок 7: Рахуємо кількість пар й виводимо результат;

Крок 8: Після вивода програми програма завершається.

_! Зауваження: на момент написання програми до мене ще не дійшло, що під парними мається на увазі “чётные” — я тоді переклав на російську як “парные”, тому я й написав так програму. Тільки на момент написання звіту під час опису першого завдання, коли мені треба було написати українською “чётные” й отримав у перекладачі “парні” — я зрозумів, що у іншій програмі мабудь малося на увазі інший результат. Заново переписувати програму я не буду — будемо вважати що така умова малася на увазі. Тим паче навіщо копіювати код з іншої програми? Краще щось нове виконати. Тому далі буде описана програма з таким кодом, як було описано раніше. А якщо дійсно малося написати таку програму, як я зрозумів, вважайте це зауваження неактуальним._

_Що очікується від програми?_ Користувач уводить елементи масива сам, чи вибирає автоматичну генерацію, й на виході отримує кількість парних елементів. Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n6.png"/>
</p>

_Результат:_ як бачимо, елементи дійсно генеруються і якщо ми порахуємо власноруч — отримаємо, що програма правильно рахує кількість парних елементів масива (елементів які мають пару, а не діляться на 2). _Вважаємо завдання виконаним! ✔ _

Для <u>завдання 5</u> написано загальну структуру програми так:

Крок 1: Оголошуємо масив 5*5;

Крок 2: Передаємо його у конструктор;

Крок 3: Генеруються елементи масива від 10 до 25;

Крок 4: Записуються ці елементи у ряд;

Крок 5: За завданням моя програма має ЗАПИСУВАТИ ці згенеровані елементи за певною послідовністю, тому я замінюю з певного елемента масива у певному напрямку на певну кількість елементів з певного ряда нульові елементи:

Крок 5.1: Перевіряю, у якому напрямку йде зміна (по x чи y), вектор зміни (збульшення чи зменшення) і наскільки треба просунутися у заданому напрямку;

Крок 5.2: Починається зміна з певної координати;

Крок 5.3: Виконується проходження, замінюючи вказану кількість елементів;

Крок 6: Після виконання всіх викликів виводжу результат сформованого масиву;

Крок 7: Після вивода результата програма завершається.

_! Зауваження: за кроком 3 треба було генерувати елементи від 1 до 25, але для краси результата було вирішено обмежити цей інтервал з 1 до 10. Пояснення написано у коментарі у коді._

_Що очікується від програми?_ Виводиться масив згенерованих у тому порядку який задано у завданнях на іллюстрації 1. Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n7.png"/>
</p>

_Результат:_ спочатку генерується ряд елементів, а потім він записується у масив. Це можна перевірити у коді. _Вважаємо завдання виконаним! ✔ _

Для <u>завдання 6</u> уявімо, що массив 5*5 є одномірним масивом із 25 елементів. Елементи між собою відносяться так: [0][0] = [0], [0][1] = [1], ..., [0][4] = [4], [1][0] = [5], [1][1] = [6], ..., [4][3] = [23], [4][4] = [24] (нагадаємо, що нумерація починається з 0, а не з 1, тому п’ятий елемент буде під номером 4), тому опишеться загальна структура програми так:

Крок 1: Переберемо кожен з 25 елементів;

Крок 2: Кожен парний елемент буде 0, а не парний 1;

Крок 3: Запишемо кожен елемент до матриці;

Крок 4: Після перебірки виведемо готову матрицю;

Крок 5: Після виведення масива програма завершається.

_Що очікується від програми?_ Масив наступного вигляду:

<table>
  <tr>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td rowspan="4">
      1
    </td>
  </tr>
  <tr>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td rowspan="4">
      0
    </td>
  </tr>
  <tr>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td rowspan="4">
      1
    </td>
  </tr>
  <tr>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td rowspan="4">
      0
    </td>
  </tr>
  <tr>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td>
      1
    </td>
    <td>
      0
    </td>
    <td rowspan="4">
      1
    </td>
  </tr>
</table>

Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n8.png"/>
</p>

_Результат:_ Програма заповнює масив нолями та одиницями так, як потрібно. _Вважаємо завдання виконаним! ✔ _

Для <u>завдання 7</u> необхідно написати багато коду (так кажеться на перший вигляд), але якщо не брати до уваги частину зі спілкування, то кода там написано менше, ніж у деяких інших програми цих завдань. Загальна структура програми виглядає так:

Крок 1: Дізнатися у користувача розмір масива, який йому потрібен;

Крок 2: Якщо зазначені розміри менше максимальних — дізнатися про межі генерації елементів;

Крок 3: Динамічно оголосити масив;

Крок 4: Згенерувати елементи масива;

Крок 5: Вивести масив;

Крок 6: Динамічно оголосити ряд (у завданні ніде не було задано цього ряду, тому мається на увазі, що програма має його згенерувати як масив);

Крок 7: Згенерувати елементи ряда;

Крок 8: Вивести ряд;

Крок 9: Замінити елементи масива відповідними елементами ряда (як це робити я розказано вже два рази у цьому звіті);

Крок 10: Вивести новий масив;

Крок 11: Після виведення масива програма завершається.

_Що очікується від програми?_ Має згенеруватись і вивести перший масив, ряд (елементи якого мають замінити елементи масива) і новий масив (пісдя заміни елементів). Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n9.png"/>
</p>

_Результат:_ Програма працює так, як задано завданням: генерує масив, ряд, і замінює елементи масива елементами з ряда. Зауважу, що пам’ять під масив і ряд виділяється динамічно. Ще відмічу, що на генерацію у цій програмі було затрачено рівно одна хвилина — 30с на масив і 30с на ряд. _Вважаємо завдання виконаним! ✔ _

Для <u>завдання 8 треба</u> працювати вже зі строками, які, свого роду, є масивами, але зберігають не цифри, а символи. Опишемо загальну структуру програми так:

Крок 1: Програма запам’ятовує уведену користувачем строку;

Крок 2: Програма перебирає усі символи ряда;

Крок 3: Коли знайдено “пробіл” — збільшити показник кількості слів на одиницю (так як після останнього слова нема пробілу — програма не буде рахувати це слово, тому програма завжди буде стартувати вже зі значенням “1”: хоча б одна буква вже може бути словом);

Крок 4: Коли знайдено “пробіл”, а перед ним стоїть знак “тире” — не збульшувати показник кількості слів (всі знаки пунктуації, окрім “тире”, пишуться відразу після слова й тільки “тире” пишеться так, що з обох його сторін має стояти пробіл — правила пунктуації у мові. Взагалі кажучи, ця програма вважає всі знаки пунктуації частиною слова, а тому і одиноке “тире” буде рахуватись словом. Щоб такого не виникало — написана ця перевірка);

Крок 5: Виводиться кількість слів;

Крок 6: Перебрати кожен символ рядка до ‘\0’ (або “порахувати кількість введених користувачем символів”);

Крок 7: Вивести кількість символів ряда;

Крок 8: Поділити ряд на слова;

Крок 9: У кожному слові перевірити сусідні букви;

Крок 10: Якщо співпадінь нема — занести слово у новий ряд;

Крок 11: Якщо є співпадіння — пропустити слово:

Крок 12: Вивести нове речення;

Крок 13: Після виведення результата програма завершається.

_Що очікується від програми?_ Програма запрошує ввести речення, й після отримання результата виводить кількість слів, символів і нове речення без слів, у яких є сподвоєнні літери. Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/14%20-18%20Lab%202%20Sem%201%20Course%20-%20Combination%20La&aposs%20n10.png"/>
</p>

_Результат:_ Я власноруч перерахував букви й слова — все співпадає. Нове речення теж правильно написано — подвоєнні літери є тільки в слові програміст (всі програми розраховані під російську мову). _Вважаємо завдання виконаним! ✔ _

_! Зауваження про генерацію масивів: для рандомної генерації за ядро генератора береться поточний час, а так як генерація відбувається дуже швидко — за ядро береться один час і генерується одне й те саме число. Щоб цього уникнути — потрібен інтервал >1 секунди, тому генерацыя кожного елемента завжди відбуватиметься 1,25 секунди. Умовно кажечи, масив 15*15 буде генеруватися (15 * 15 = 225 елементов * 1,25 = 281,25 секунди / 60 =) трішки більше 4,5 хвилини. Ця затримка потрібна для реально рандомної генерації._

Код:
```cpp
#include <iostream>
#include <windows.h>
using namespace std;

// REVIEW
//  =============================   АВТОРСТВО   =============================
//  -
//  Написал код:
//  Начинающий программист - Калиновский Валентин
//  -
//  =============================   ВСТУПЛЕНИЕ   ============================
//  -
//  Здесь я написал код к следующим лабораторным заданиям:
//  1) Циклы (Лаб 1 : Сем2 | Лаб 14 : Курс1) - задания ONE, TWO, THREE
//  2) Одномерные массивы (Лаб 2 : Сем2 | Лаб 15 : Курс1) - задание FOUR
//  3) Двумерные массивы (Лаб 3 : Сем2 | Лаб 16 : Курс1) - задания FIVE, SIX
//  4) Динамические массивы (Лаб 4 : Сем2 | Лаб 17 : Курс1) - задание SEVEN
//  5) Обработка строк (Лаб 5 : Сем2 | Лаб 18 : Курс1) - задание EIGHT
//  -
//  ==============================   НАСТРОЙКА   ============================
//  ====================   ВЫБЕРИТЕ НОМЕР КОДА ЗАДАНИЯ   ====================
//  -
//  Для выбора введите в поле #define под этим комментарием один из
//  следуюущих номеров: ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT
//  -
//  =========================================================================
// CHOISE:

#define EIGHT


// NOTE: здесь описана функция для вывода двумерных массивов, чтобы не копировать
//  её в каждый класс, где она нужна.
template <typename T>
void printMass(T Mass, int width, int height)
{
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
            cout << Mass[i][j] << " ";
        cout << "\n";
    }
}

#ifdef ONE
class One{
public:
    One()
    {
        while (i <= 300)
        {
            if (i % 2 == 0)
            {
                if (i % 13 == 0)
                {
                    if (i + 13 > 300 || i + 13 * 2 > 300)
                        cout << i;
                    else
                        cout << i << " + ";
                    Sum += i;
                }
            }
            i++;
        }
        cout << " = " << Sum;
    }

private:
    int Sum = 0, i = 1;
};
#endif //ONE


#ifdef TWO
class Two{
public:
    Two()
    {
        do {
            for (int j = 2; j < i; j++)
            {
                if (i % j == 0)
                {
                    SampleInt = false;
                    j = i;
                }
                else
                    SampleInt = true;
            }
            if (SampleInt)
                cout << i << " ";
            i++;
        } while (i <= 300);
    }

private:
    int i = 1;
    bool SampleInt;
};
#endif //TWO


#ifdef THREE
class Three{
public:
    Three()
    {
        for (int i = 1; i < 10; i++)
        {
            for (int j = i; j < 10; j++)
            {
                a = j;
                printResult(a, b, c);
            }
            a = i;
            for (int j = i; j < 10; j++)
            {
                b = j;
                printResult(a, b, c);
            }
            b = i;
            for (int j = i; j < 10; j++)
            {
                c = j;
                printResult(a, b, c);
            }
            c = i;
            for (int j = i; j < 10; j++)
            {
                a = j;
                b = j;
                printResult(a, b, c);
            }
            a = i;
            b = i;
            for (int j = i; j < 10; j++)
            {
                a = j;
                c = j;
                printResult(a, b, c);
            }
            a = i;
            c = i;
            for (int j = i; j < 10; j++)
            {
                b = j;
                c = j;
                printResult(a, b, c);
            }
            b = i;
            c = i;
            for (int j = i; j < 10; j++)
            {
                a = j;
                b = j;
                c = j;
                printResult(a, b, c);
            }
            a = i;
            b = i;
            c = i;
        }
    }

private:
    int a = 1, b = 1, c = 1;
    static void printResult(int a, int b, int c)
    {
        if ((a * b) - (c * c * c) - 9 == 0)
            cout << "Результат: a = " << a << " , b = " << b << " , c = " << c << "\n";
    }
};
#endif //THREE


#ifdef FOUR
// NOTE: дополнительно мне нужны библиотеки для работы с генератором и временем -
#include <random>
#include <ctime>

class Four{
public:
    Four()
    {
        cout << "Как заполнить массив? Вы сами его введёте (1), или массив должен сгенерироваться программно (2)?\n";
        cin >> answer;
        switch (answer)
        {
            case 1:
                for (int i = 0; i < 15; i++)
                {
                    cout << "\n" << i + 1 << " элемент массива: ";
                    cin >> Mass[i];
                }
                break;
            case 2:
                for (int i = 0; i < 15; i++)
                {
                    srand(time(NULL));
                    Sleep(1500);
                    Mass[i] = 1 + rand() % 18;
                    cout << "\n" << i + 1 << " элемент массива: " << Mass[i];
                }
                break;
            default:
                cout << "Введено неправильное значение! Ответ принимается за \"2\":\n";
                for (int i = 0; i < 15; i++)
                {
                    srand(time(NULL));
                    Sleep(1500);
                    Mass[i] = 1 + rand() % 18;
                    cout << "\n" << i + 1 << " элемент массива: " << Mass[i];
                }
                break;
        }
        // BUG: Почему то здесь при проверке значений цикл не хочет работать, если два парных
        //  элемента идут по соседству, например, если 13 и 14 элемент буду равны, он их
        //  всё равно в сумму не засчитает - он посчитает суму для элемента 13 с любыми
        //  элементами, только если это не 12 и 14 элементы. Аналогично и для других...
        for (Num = 1; Num < 15; Num++)
        {
            if (prov == Mass[Num])
            {
                Sum++;
            }
            if (Num == 14)
            {
                prov = Mass[counter];
                Num = counter + 1;
                counter++;
            }
        }
        cout << "\nСумма пар: "<< Sum << "\n";
    }

private:
    int Mass[15]{}, answer{}, Num = 0, prov = Mass[Num], Sum = 0, counter = 1;
};
#endif //FOUR


#ifdef FIVE
// NOTE: дополнительно мне нужны библиотеки для работы с генератором и временем -
#include <random>
#include <ctime>

class Five{
public:
    Five(int Mass[5][5])
    {
        cout << "Сначала нужно сгенерировать (5*5=) 25 элементов:\n";
        for (int & element : elements)
        {
            // NOTE: для красоты вида результата я решил ограничить диапазон с 1 - 25 до
            //  10 - 25. Волноваться не стоит: все эти элементы входя в множество диапазона
            //  1 - 25, а матрица выглядит ровной и красивой.
            srand(time(NULL));
            Sleep(1250);
            element = 10 + rand() % 15;
            cout << element << " ";
        }
        cout << "\nДальше, относительно схемы своего варианта, я заполняю двумерный массив\n"
                "этими элементамив этой последовательности. Результат:\n";
        filling(elements, Mass, &num, 'y', '+', 5, 0, 0);
        filling(elements, Mass, &num, 'x', '+', 4, 4, 1);
        filling(elements, Mass, &num, 'y', '-', 4, 3, 4);
        filling(elements, Mass, &num, 'x', '-', 3, 0, 3);
        filling(elements, Mass, &num, 'y', '+', 3, 1, 1);
        filling(elements, Mass, &num, 'x', '+', 2, 3, 2);
        filling(elements, Mass, &num, 'y', '-', 2, 2, 3);
        filling(elements, Mass, &num, 1, 2);
        filling(elements, Mass, &num, 2, 2);
    }

private:
    int elements[25]{}, num = 0;
    static void filling(const int el[25], int mass[5][5], int *Num, char direction, char sign, int amount, int y, int x)
    {
        int z = 0;
        while (z < amount)
        {
            if (direction == 'x' && sign == '+')
            {
                mass[y][x] = el[*Num];
                x++;
                *Num = *Num + 1;
            }
            else if (direction == 'y' && sign == '+')
            {
                mass[y][x] = el[*Num];
                y++;
                *Num = *Num + 1;
            }
            else if (direction == 'x' && sign == '-')
            {
                mass[y][x] = el[*Num];
                x--;
                *Num = *Num + 1;
            }
            else if (direction == 'y' && sign == '-')
            {
                mass[y][x] = el[*Num];
                y--;
                *Num = *Num + 1;
            }
            z++;
        }
    }
    static void filling(const int el[25], int mass[5][5], int *Num, int y, int x)
    {
        mass[y][x] = el[*Num];
        *Num = *Num + 1;
    }
};
#endif //FIVE


#ifdef SIX
class Six{
public:
    explicit Six(int Mass[5][5])
    {
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 5; j++)
            {
                if (count % 2 == 0)
                    Mass[i][j] = 1;
                else
                    Mass[i][j] = 0;
                count++;
            }
        }
    }

private:
    int count = 0;
};
#endif //SIX


#ifdef SEVEN
// NOTE: дополнительно мне нужны библиотеки для работы с генератором и временем -
#include <random>
#include <ctime>

class Seven{
public:
    Seven()
    {
        cout << "\nВведите размеры массива:\nКоличество строчек - ";
        cin >> height;
        cout << "Количество элементов каждой строки - ";
        cin >> width;
        length = height * width;
        if (height <= HEIGHT && width <= WIDTH)
        {
            cout << "\nС какого числа должен генерироваться числа для массива? ";
            cin >> intA;
            cout << "До какого? ";
            cin >>intB;
            intB -= intA;
            isStart = true;
        }
        else
        {
            cout << "Ошибка ввода: размер массива больше максимального!";
            isStart = false;
        }
    }
    ~Seven()
    {
        for (int count = 0; count < height; count++)
            delete []Mass[count];
        delete []Mass;
        delete []Series;
    }
    void isWork()
    {
        if (isStart)
            works();
    }

private:
    // NOTE: так как максимальные размеры не заданы - я сам их придумал и установил.
    const int HEIGHT = 15, WIDTH = 15;
    bool isStart;
    int height{}, width{}, intA{}, intB{}, length{}, numSeries = 0, **Mass{}, *Series{};
    void works()
    {
        cout << "\nГенерируем начальную матрицу:\n";
        Mass = new int*[height];
        for (int count = 0; count < height; count++)
        {
            Mass[count] = new int[width];
            for (int j = 0; j < width; j++)
            {
                srand(time(NULL));
                Sleep(1250);
                Mass[count][j] = intA + rand() % intB;
                cout << Mass[count][j] << " ";
            }
            cout << "\n";
        }
        // NB: во-первых, я предположу, что этот одномерный массив есть ряд, элементы
        //  которого соответствуют так - {[0][0] = [0], [1][1] = [1], ...,
        //  [0][4] = [4], [1][0] = [5], [1][1] = [6], ..., [4][4] = [24]}, и, во-вторых, так
        //  как нигде в задании не был задан этот ряд, я предположу, что мне для его выполнения
        //  нужно заново провести туже работу, что и для двумерного массива, за исключением, что
        //  это будет одномерный ряд и потом, как требуется, просто заменить старые соответствующие
        //  элементы на новые соответствующие из нового ряда, а выводить нужно первоначальный
        //  массив, новый ряд и новый массив. Так я понял и так поступлю.
        cout << "\nГененрируем новый одномерный массив с количеством элементов\n"
                "начальной матрицы: (" << height << "*" << width << "=) " << length << " элементов.\n\n"
                "Все элементы генерируются в том же диапазоне.\n\nНовый ряд:\n";
        Series = new int[length];
        for (int i = 0; i < length; i++)
        {
            srand(time(NULL));
            Sleep(1250);
            Series[i] = intA + rand() % intB;
            cout << Series[i] << " ";
        }
        cout << "\n\nЗаменим каждый элемент начального массива соответствующими элементами из ряда.\n";
        for (int i = 0; i < height; i++)
            for (int j = 0; j < width; j++)
            {
                Mass[i][j] = Series[numSeries];
                numSeries++;
            }
        cout << "\nВыводим результат - новая матрица:\n";
        printMass(Mass, width, height);
    }
};
#endif //SEVEN


#ifdef EIGHT
#include <string>
class Eight{
public:
    Eight()
    {
        cout << "Введите строку: ";
        cin.getline(userSTR, 140);
        countWord();
        WordSuggestion();
        checkDubbling();
    }
private:
    string word;
    char userSTR[140]{}, userSTRnew[140]{}, *userSTRword{};
    int countSymbol = 0, countWORD = 1;
    bool check{};
    void countWord()
    {
        for (int i = 0; i < sizeof(userSTR) / sizeof(char); i++)
            if (userSTR[i] == ' ' && userSTR[i - 1] != '-')
                countWORD++;
        cout << "\nКоличество слов в вашем тексте: " << countWORD;
    }
    void WordSuggestion()
    {
        for (char i : userSTR)
            if (i != '\0')
                countSymbol++;
        cout << "\nКоличество написанных символов: " << countSymbol;
    }
    void checkDubbling()
    {
        userSTRword = strtok(userSTR, " ");
        while (userSTRword != nullptr)
        {
            word = userSTRword;
            for (int j = 0; j < word.size(); j++)
            {
                if (userSTRword[j] == userSTRword[j + 1] && userSTRword[j + 1] != '.')
                {
                    check = false;
                    break;
                }
                else
                    check = true;
            }
            if (check)
                strcat(userSTRnew, userSTRword);
            strcat(userSTRnew, " ");
            userSTRword = strtok(nullptr, " ");
        }
        strcat(userSTRnew, "\0");
        cout << "\n\nНовое предложение без слов с удвоенными буквами:\n\" " << userSTRnew << "\"";
    }
};
#endif //EIGHT

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    char end[] = "\n\nКонец задания.\n";
#ifdef ONE
    cout << "Подготовил Калиновский Валентин.\nПервое задание (лабораторная №1):\n\n";
    One one;
    cout << end;
#endif //ONE
#ifdef TWO
    cout << "Подготовил Калиновский Валентин.\nВторое задание (лабораторная №1):\n\n";
    Two two;
    cout << end;
#endif //TWO
#ifdef THREE
    cout << "Подготовил Калиновский Валентин.\nТретье задание (лабораторная №1):\n\n";
    Three three;
    cout << end;
#endif //THREE
#ifdef FOUR
    cout << "Подготовил Калиновский Валентин.\nЗадание по лабораторной №2:\n\n";
    Four four;
    cout << end;
#endif //FOUR
#ifdef FIVE
    cout << "Подготовил Калиновский Валентин.\nПервое задание (лабораторная №3):\n\n";
    int Mass[5][5];
    Five five(Mass);
    printMass(Mass, 5, 5);
    cout << end;
#endif //FIVE
#ifdef SIX
    cout << "Подготовил Калиновский Валентин.\nВторое задание (лабораторная №3):\n\n";
    int Mass[5][5];
    Six six(Mass);
    printMass(Mass, 5, 5);
    cout << end;
#endif //SIX
#ifdef SEVEN
    cout << "Подготовил Калиновский Валентин.\nЗадание по лабораторной №4:\n\n";
    Seven seven;
    seven.isWork();
    cout << end;
#endif//SEVEN
#ifdef EIGHT
    cout << "Подготовил Калиновский Валентин.\nЗадание по лабораторной №5:\n\n";
    Eight eight;
    cout << end;
#endif //EIGHT
    cin.get();
    cin.get();
    return 0;
}
```

### Висновок

Всі завдання було виконано й усі програми виконують свій функціонал — що від них потребується, те вони й виконують. Ми ознайомились з операторами циклів, принципами формування одновимірних, двовимірних, динамічних масивів, вивчили способи виділення пам’яті для динамічних масивів, навчились будувати математичну модель задачі, вивчили методи перевірки правильності вхідних даних, вивчили можливості оголошення та ініціалізації рядів, вивчили головні функції роботи з рядами, засвоїли використання головних функцій бібліотек та головне: отримали практичні навики в написанні програм.

[Ссылка на методичку и готовые программы](https://drive.google.com/drive/folders/1RXO-AE5_Zdf1I9oHpqBNrX2LsSuVmVyB?usp=sharing)
