<p align='center'>
    Центральноукраїнський національний технічний унiверситет<br>
    Кафедра програмування комп’ютерних систем і мереж<br>
    Дисципліна: Базові технології та методології програмування<br><br><br>
</p>
<p align='center'>
    Звiт<br>
    з лабораторної роботи 11–12<br>
    Тема: Програмування з використанням підпрограм та модулів користувача<br><br>
    Мета роботи: Навчитись визначатись з функціями (процедурами) користувача у задачі та складати програми з їх використанням; навчитись створювати модуль користувача та використовувати різні його елементи (типи, змінні, підпрограми) у програмі.<br><br><br>
</p>
<p align='right'>
    Виконав: ст. гр. КМ-20<br>
    Калиновський В.М.<br>
    Перевірила: асистент кафедри ПКСМ<br>
    Тесленко О.Є.<br>
    Варіант 3<br><br><br>
</p>
<p align='left'>
    Дата виконання: 02.12.2020<br>
    Дата оформлення: 02.12.2020<br>
    Дата переоформлення: 18.01.2021<br><br>
</p>
<p align='center'>
    <s>Кропивницький 2020 р.</s><br>
    Кропивницький 2021 р.<br>
</p>

### Завдання

Написати підпрограму-функцію, що визначає периметр N-кутників, координати X та Y яких задає користувач, а довжина сторін обчислюється в підпрограмі; Написати підпрограму-процедуру, що обчислює і запам’ятовує суму позитивних елементів кожного рядка A(10; 20) та B(15; 10); Створити модуль користувача, до складу якого включити як мінімум 2 типи користувача, функцію та процедуру користувача, створити одну чи декілька програм, в яких скористатись типами, функцією та процедурою створеного модуля.

_Зразу відмічу, що завдання були з розрахунком на те, що коди будуть писатися на мові Pascal. Так як Pascal ми вивчаємо тільки у першому семестрі, а робота дороблюється вже на другий, то я програми писав вже тільки на мові С++._


### Робота

_02.12.2020 --->_

Складаю алгоритм моєї програми:

1. Користувач вводить кількість кутів (розмірність фігури (масива координат))
2. Далі користувач вводить координати точок
3. Програма розраховує довжину кожної сторони
4. У кінці програма рахує загальний периметр й виводить результат

У таблиці 1 розписано код програми, а на рисунку 1 зображено результат програми. Для перевірки результату давайте вигадаємо якусь фігуру з випадковими координатами, а потім самостійно порахуємо й звіримо результати.

Код 1:
```cpp
#include <iostream> //Подключаю эту библиотеку, так как только она корректно работает с вводом значений в двумерный массив
#include <Windows.h>
#include <math.h>

using namespace std;

//Функция расчёта периметра
float Perimetr(float TablDlin[], int NKut) {
    float Perim = TablDlin[0];
    for (int j = 1; j < NKut; j++) {
        Perim = Perim + TablDlin[j];
    }
    cout << "\n\nПериметр равен " << Perim;
    return Perim;
}

int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    unsigned int NKut;
    cout << "Введите количество углов в Н-кутнике: ";
    cin >> NKut; //Ввожу количество углов - размер массива
    int *Masy = new int[NKut]; //Строка, которая позволяет создать массив без задания размера массива

    //В следующем цикле пользователь вводит координаты углов. Они записываются в массив
    int TablCoord[NKut][2];
    for (unsigned int i = 0; i <= NKut - 1; i++) {
        cout << "\n\nВведите координаты " << i + 1 << " угла:";
        cout << "\nX = ";
        cin >> TablCoord[i][0];
        cout << "Y = ";
        cin >> TablCoord[i][1];
    }
    cout << "\n\nЗначения притняты. Вызываем функции расчёта длин и периметра...";

    //Создаю массив, который будет хранить длины сторон
    float TablDlin[NKut];
    for (unsigned int k = 0; k < NKut; k++) {
        if (k == NKut - 1) {
            TablDlin[k] = sqrt(((TablCoord[0][0] - TablCoord[k][0]) * (TablCoord[0][0] - TablCoord[k][0])) + ((TablCoord[0][1] - TablCoord[k][1]) * (TablCoord[0][1] - TablCoord[k][1])));
        }
        else {
            TablDlin[k] = sqrt(((TablCoord[k + 1][0] - TablCoord[k][0]) * (TablCoord[k + 1][0] - TablCoord[k][0])) + ((TablCoord[k + 1][1] - TablCoord[k][1]) * (TablCoord[k + 1][1] - TablCoord[k][1])));
        }
        cout << "\nСторона N" << k + 1 << " = " << TablDlin[k];
    }
    Perimetr(TablDlin, NKut); //Вызываю функцию, которая просчитает периметр

    delete[] Masy; //Удаляю массив

    system("pause");
    return 0;
}
```

Рисунок 1:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/11-12%20Lab%201%20Sem%20%201%20Course%20-%20Function%20n1.png"/>
</p>

Розрахунки можуть бути неточні, так як для розрахунку запам’ятовуюча змінна має бути типу double, але вона прописана як float. У попередженнях компілятора з’являється повідомлення про можливі втрати. Будемо мати це на увазі. Перевіряючи функцію, чи працює підрахунок периметра виявляємо – функція працює справно. Давайте перевіримо, чи правильно працює підрахунок сторін:

    A(5: 7), B(14; 19), C(15; 19), D(8; 15)
    1. AB = sqrt((14 - 5)^2 + (19 - 7)^2) = sqrt(9^2 + 2^2) = sqrt(85) = 9,2195
    2. BC = sqrt((15 - 14)^2 + (19 - 19)^2) = sqrt(1) = 1
    3. CD = sqrt((8 - 15)^2 + (15 - 19)^2) = sqrt((-7)^2 + (-4)^2) = sqrt(65) = 8,0622
    4. DA = sqrt((5 - 8)^2 + (7 - 15)^2) = sqrt((-3)^2 + (-8)^2) = sqrt(75) = 8,4852
    d = 26,7669

Як ми бачимо, програма неправильно порахувала першу й останню сторони, але правильно другу й третю. Тому неправильні підрахунки ми можемо списати на втрати при переформатуванні змінних.

_18.01.2020 --->_

<p align='center'>
    <i>Коли я сів допрацьовувати роботу, я перейшов працювати та писати програми на Linux. Надалі всі коди будуть розроблятись під іншу систему. Я буду використовувати редактори кодів, IDE, бібліотеки, ресурси, офісний пакет, які будуть відмінні від тих, що потребуються, у зв’язку з необхідністю – у мене немає можливості використовувати ліцензоване програмне забезпечення від Microsoft, тому я буду користуватися Open Sourse.</i><br>
</p>
<p align='center'>
    <i>У зв’язку з переходом на новий офісний пакет я вимушений частково змінити свій стиль оформлення, який можливо буде використовувати від нового офісного пакету.</i><br>
</p>

Код першої програми я переписав, зробивши її структурованою. Алгоритм, математичний розв’язок та результат не змінились. Змінились код та вигляд результату (через зміну оболочки системи). Для виконання першого завдання я написав наступний код:

```cpp
#include <iostream> //Подключаю эту библиотеку, так как только она корректно работает с вводом значений в двумерный массив
#include <math.h>

using namespace std;

//Функция расчёта периметра
float Perimetr(float TablDlin[], int NKut) {
	float Perim = TablDlin[0];
	for (int j = 1; j < NKut; j++) Perim = Perim + TablDlin[j];
	return Perim;
}

void CountDlin(int TablCoord[][2], int NKut) {
	//Создаю массив, который будет хранить длины сторон
	float TablDlin[NKut];
	for (int k = 0; k < NKut; k++) {
if (k == NKut - 1) TablDlin[k] = sqrt(((TablCoord[0][0] — TablCoord[k][0]) * (TablCoord[0][0] - TablCoord[k][0])) + ((TablCoord[0][1] — TablCoord[k][1]) * (TablCoord[0][1] - TablCoord[k][1])));
else TablDlin[k] = sqrt(((TablCoord[k + 1][0] - TablCoord[k][0]) * (TablCoord[k + 1][0] - TablCoord[k][0])) + ((TablCoord[k + 1][1] - TablCoord[k][1]) * (TablCoord[k + 1][1] - TablCoord[k][1])));
		cout << "\nСторона N" << k + 1 << " = " << TablDlin[k];
	}
	cout << "\n\nПериметр равен " << Perimetr(TablDlin, NKut) << "\n\n";
}

void CreatedMassiv(int NKut) {
	//В следующем цикле пользователь вводит координаты углов. Они записываются в массив
	int TablCoord[NKut][2];
	for (int i = 0; i < NKut; i++) {
		cout << "\n\nВведите координаты " << i + 1 << " угла:";
		cout << "\nX = ";
		cin >> TablCoord[i][0];
		cout << "Y = ";
		cin >> TablCoord[i][1];
	}
	cout << "\n\nЗначения притняты. Вызываем функции расчёта длин и периметра...";
	CountDlin(TablCoord, NKut);
}

int Start() {
	int NKut;
	cout << "Введите количество углов в Н-кутнике: ";
	cin >> NKut; //Ввожу количество углов - размер массива
	return NKut;
}

int main() {
	CreatedMassiv(Start());
	cin.get(); cin.get();
	return 0;
}
```

Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/11-12%20Lab%201%20Sem%20%201%20Course%20-%20Function%20n2.png"/>
</p>

Для перевірки роботи програми я завчасно зробив графік, на якому я розташував п’ятикутник, точки углів якого я взяв і взяв для розрахунку. Між точками я клав лінійку для точного виміру відстанні між точками, й у данному випадку неправильно пораховано тільки третя сторона, довжина якої має бути на пару сантиметрів менше. Загалом програма працює правильно.
За алгоритм другої програми було взято:

1. Передаю у функцію генерації масива її розмір
2. Генерую масив
3. Сумую позитивні елементи кожної строчки
4. Виводжу результати

Для реалізації цього алгоритму я написав наступний код:
```cpp
#include <iostream>
#include <random>
#include <ctime>

using namespace std;

void GenSortMassiv(char N, int a, int b) {
	srand(time(NULL)); //Нужно для генерации реально рандомного массива, которая 			зависит только от текущего времени
	cout << "\n\nГенерируем массив " << N << "(" << a << ", " << b << "):\n";
	int Massiv[a][b];
	for (int i = 0; i < a; i++) {
		for (int j = 0; j < b; j++) {
			Massiv[i][j] = (-50) + rand() % 100;
			if (j == b - 1) cout << Massiv[i][j] << "\n";
			else cout << Massiv[i][j] << " ";
		}
	}

	cout << "\n" << "Считаем суммы позитивных элементов каждой строчки массива:";
	int SumEL[a];
	for (int m = 0; m < a; m++) {
		SumEL[m] = 0;
		for (int n = 0; n < b; n++) {
			if (Massiv[m][n] > 0) SumEL[m] += Massiv[m][n]; //Считаю положительные числа
			if (n == b - 1) cout << "\n" << "Строчка №" << m + 1 << ": сумма равна " << 	SumEL[m];
		}
	}
}

int main() {
	GenSortMassiv('A', 10, 20); //Вызываю функцию для генерации массива 10 на 20
	GenSortMassiv('B', 15, 10); //Вызываю функцию для генерации массива 15 на 10
	cin.get();
	return 0;
}
```

Результат:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/11-12%20Lab%201%20Sem%20%201%20Course%20-%20Function%20n3.png"/>
</p>

Під час написання програми для перевірки кожної функції я прописав команду для виводу значення рахунку суми у цикл, тому я міг продивитись стан змінної на кожний етап. Програма дійсно рахує тільки позитивні числа, оскільки значення суми змінювалось тільки на позитивних елементах й на стільки, чому дорівнює оцей елемент. Під час редагування методів виводу я прибрав цю функцію, щоб отримувати тільки кінцевий результат. Але я впевнений, що підрахунок проводиться правильно.

Після другого масиву виведено усього 7 строчок. Це пов’язано з тим, що інші строчки просто не вмістилися на екран монітору.

Як ми бачимо, програма генерує масиви, а аналізуючи головну функцію програми ми впевнюємося, що вона може робити це скільки завгодно і як завгодно (під “як завгодно” я маю на увазі розмір масиву — він може бути любим). Це ми використаємо для третього завдання, а зараз ми робимо висновок, що програма впорюється з поставленими їй завданнями. Програма робоча.

Приступаємо до третього завдання. Для його використання я виконую ті самі перше та друге завдання, тільки я із головних виконуючих кодів залишу тільки головні функції, всі інші я перенесу у свою бібліотеку. Як це робити на С++ я дізнався сам. Реалізацію я напишу разом з результатами.

Як працюють статичні бібліотеки: при виклику компілятора спочатку викликається лінковщик — він просто копіює увесь вміст бібліотеки замість строчки виклику цієї бібліотеки у виконуючий код і тільки потім новий (уже повний) код передає компілятору на компіляцію.

І так, я всі функції, крім головних, виношу у Хідер з обох програм. Залишаються:

_з першої програми_
```cpp
#include "KalinkaLibForLab1112.h"

using namespace std;

int main() {
	CreatedMassiv(Start());
	cin.get(); cin.get();
	return 0;
}
```

_з другої програми_
```cpp
#include "KalinkaLibForLab1112.h"

using namespace std;

int main() {
	GenSortMassiv('A', 10, 20);
	GenSortMassiv('B', 15, 10);
	cin.get();
	return 0;
}
```

_бібліотека_
```cpp
#include <iostream>
#include <math.h>
#include <random>
#include <ctime>
#ifndef _KalinkaLibForLab1112_
#define _KalinkaLibForLab1112_

using namespace std;

//========== Код для первой программы из этой лабораторки ==========

float Perimetr(float TablDlin[], int NKut) {
	float Perim = TablDlin[0];
	for (int j = 1; j < NKut; j++) Perim = Perim + TablDlin[j];
	return Perim;
}

void CountDlin(int TablCoord[][2], int NKut) {
	//Создаю массив, который будет хранить длины сторон
	float TablDlin[NKut];
	for (int k = 0; k < NKut; k++) {
if (k == NKut - 1) TablDlin[k] = sqrt(((TablCoord[0][0] — TablCoord[k][0]) * (TablCoord[0][0] - TablCoord[k][0])) + ((TablCoord[0][1] - TablCoord[k][1]) * (TablCoord[0][1] - TablCoord[k][1])));
else TablDlin[k] = sqrt(((TablCoord[k + 1][0] - TablCoord[k][0]) * (TablCoord[k + 1][0] - TablCoord[k][0])) + ((TablCoord[k + 1][1] - TablCoord[k][1]) * (TablCoord[k + 1][1] - TablCoord[k][1])));
		cout << "\nСторона N" << k + 1 << " = " << TablDlin[k];
	}
	cout << "\n\nПериметр равен " << Perimetr(TablDlin, NKut) << "\n\n";
}

void CreatedMassiv(int NKut) {
	//В следующем цикле пользователь вводит координаты углов. Они записываются в массив
	int TablCoord[NKut][2];
	for (int i = 0; i < NKut; i++) {
		cout << "\n\nВведите координаты " << i + 1 << " угла:";
		cout << "\nX = ";
		cin >> TablCoord[i][0];
		cout << "Y = ";
		cin >> TablCoord[i][1];
	}
	cout << "\n\nЗначения притняты. Вызываем функции расчёта длин и периметра...";
	CountDlin(TablCoord, NKut);
}

int Start() {
	int NKut;
	cout << "Введите количество углов в Н-кутнике: ";
	cin >> NKut; //Ввожу количество углов - размер массива
	return NKut;
}

//========== Код для второй программы из этой лабораторки ==========

void GenSortMassiv(char N, int a, int b) {
	srand(time(NULL));
	cout << "\n\nГенерируем массив " << N << "(" << a << ", " << b << "):\n";
	int Massiv[a][b];
	for (int i = 0; i < a; i++) {
		for (int j = 0; j < b; j++) {
			Massiv[i][j] = (-50) + rand() % 100;
			if (j == b - 1) cout << Massiv[i][j] << "\n";
			else cout << Massiv[i][j] << " ";
		}
	}

	cout << "\n" << "Считаем суммы позитивных элементов каждой строчки массива:";
	int SumEL[a];
	for (int m = 0; m < a; m++) {
		SumEL[m] = 0;
		for (int n = 0; n < b; n++) {
			if (Massiv[m][n] > 0) SumEL[m] += Massiv[m][n];
			if (n == b - 1) cout << "\n" << "Строчка №" << m + 1 << ": сумма равна " << SumEL[m];
		}
	}
}

#endif
```

На 4 та 5 рисунках буде зображено результати вже нових програм (також я наведу обставину, чому саме таку бібліотеку я вирішив написати).

Рисунок 4:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/11-12%20Lab%201%20Sem%20%201%20Course%20-%20Function%20n4.png"/>
</p>

Рисунок 5:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/11-12%20Lab%201%20Sem%20%201%20Course%20-%20Function%20n5.png"/>
</p>

Я вирішив зробити статичну бібліотеку “_ _ _ .h”, але у цьому випадку є дві реалізації: у першому — реалізація у проекті: цей метод можна використати, наприклад, у Visual Studio, де самі функції розміщуються у окремому “_ _ _ .cpp”-файлі, а у “_ _ _ .h” розміщуються тільки оголошення функцій і так правильно робити; але є ще другий метод — реалізація не у проекті: цей метод використовується, коли пишеться невеличка програмка, типу утиліти, яку можна біло б умістити навіть у одному файлі й пишеться вона не через IDE, а через звичайний редактор кода (якщо ізворотитися, можна використати навіть звичайний блокнот, а потім .txt замінити на .cpp й компілювати програму), наприклад, Visual Studio Code, Atom, Sublime Text тощо. Я користуюся VS Code та Atom’ом. У другому методі всі функції розміщуються у самому “_ _ _ .h” файлі і використовувати окремий “_ _ _ .cpp” не потрібно, але у такому випадку “Хідер” вже не буде являтися “Хідером”, так як цей файл містить вже не тільки оголошення функцій, а їх реалізацію. Це не є правильно, але коли треба написати дві маленькі програми, які використовують одні функції, але самі програмки не є проектами, то так теж можна зробити. Зазвичай, у великих проектах роблять динамічні бібліотеки — “_ _ _ .dll”, щоб сам виконуючий файл менше займав місця. Але у нашому випадку це буде не рентабельним використанням ресурсів комп’ютера, оскільки я створюю не великий проект, а малу програму, тому я буду використовувати другий метод створення статичної бібліотеки.

### Висновок

Ми навчились визначатись з функціями користувача у задачах та складати програми з їх використанням.

[Ссылка на методичку и готовые программы](https://drive.google.com/drive/folders/1VqCIzTijNh4RQikz6nrgyv4d3mC6-R59?usp=sharing)
