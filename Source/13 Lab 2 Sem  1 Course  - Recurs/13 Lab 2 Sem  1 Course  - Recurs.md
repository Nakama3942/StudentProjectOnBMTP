<p align='center'>
    Центральноукраїнський національний технічний унiверситет<br>
    Кафедра програмування комп’ютерних систем і мереж<br>
    Дисципліна: Базові технології та методології програмування<br><br><br>
</p>
<p align='center'>
    Звiт<br>
    з лабораторної роботи №13<br>
    Тема: Програмування з використанням рекурсивних функцій<br><br>
    Мета роботи: Навчитись викликати функцію з неї самої або через інші функції.<br><br><br>
</p>
<p align='right'>
    Виконав: ст. гр. КМ-20<br>
    Калиновський В.М.<br>
    Перевірила: асистент кафедри ПКСМ<br>
    Тесленко О.Є.<br>
    Варіант 3<br><br><br>
</p>
<p align='left'>
    Дата виконання: 19.01.2021<br>
    Дата оформлення: 19.01.2021<br><br>
</p>
<p align='center'>
    Кропивницький 2021 р.<br>
</p>

### Завдання з 7ої лабораторної

У середовищі розробки С++ набрати наступні задачі та виконати рекурсивні розрахунки (непарні варіанти виконують непарні задачі).

### Робота

Коли я компілював програми, я задався питанням: “Як можна зробити, щоб під час компіляції створювалися виконуючі файли з власною назвою та чим можна замінити розширення .out ?”. На перше питання я знайшов відповідь швидко: у командній строці треба вказати ключ -o, а після вказати назву з розширенням, після чого у мене й виплило друге питання. На нього було складніше знайти відповідь. Ось, що я знайшов:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/13%20Lab%202%20Sem%20%201%20Course%20%20-%20Recurs%20n1.png"/>
</p>

Потім виявилось, що у Linux може бути будь яке, розширення, може навіть його і не бути. Якщо я хочу, я можу навіть своє розширення вигадати. Як я формував назви своїх програм: першим йшло слово, скорочене від моєї фамілії, а через знак підчеркування я пишу скорочення від слова “Завдання” з його номером і закінчую розширенням. Після номера я можу вказали ще номери варіантів кодів. Приклад: “Kalinka_Zad1.exe”. Тепер я відразу після скороченої фамілії буду вказувати номер завдання, а у розширення я буду зазначати скорочення від слова “Завдання”, щоб я міг розрізняти, для чого пишу я свої програми: на навчання (.zad), у систему (.bin), а в інших випадках я виконуючі файли буду залишати без розширення. Тепер назва коду буде мати вигляд, наприклад: “Kalinka1.zad”.
Повертаємось до завдань: у першому написано сам код, у другому саму функцію рекурсії псевдокодом. Ось перший код:
```cpp
#include <iostream>

using namespace std;

long gcd(long x, long y) {
	long r;
	if (x < y) {
		r = y;
		y = x;
		x = r;
	}
	while (y) {
		r = x % y;
		x = y;
		y = r;
	}
	return (x);
}

void scdr(long *p1, long *p2) {
	long t;
	t = gcd(*p1, *p2);
	*p1/=t;
	*p2/=t;
}

int main () {
	int n;
	cout << "Введите количество членов ряда: ";
	cin >> n;
	long s1 = 0;
	long s2 = 1;
	for (int k = 0; k <= n; k++) {
		s1 = s1 * k + s2;
		s2 *= k;
		scdr(&s1, &s2);
	}
	cout << "Сумма " << n << " членов ряда: " << s1 << " / " << s2 << endl;
	return 0;
}
```

Псевдокодом для функції другої програми було:

1. Оголошення Fin(n);
2. Якщо n <= 1 тоді повернути n;
3. Інакше повернути Fin(n - 1) + Fin (n - 2).

Крім самої функції я мав описати ще й саму програму, яка мала приймати необхідні значення від користувача, які вона передасть цій функції. Це я описав у головній функції. Програма має наступний вигляд:
```cpp
#include <iostream>
//Функция расчёта ряда Фибоначи
long double Fib(int N) {
	if (N <= 1) return N;
	else return Fib(N - 1) + Fib(N - 2);
}
using namespace std;

//В главной программе пользователь вводит количестиво элементов ряда
//Фибоначи, после чего вызывается функция расчёта этого ряда.
int main() {
	int N;
	cout << "Введите количество элементов последовательности Фибоначи: ";
	cin >> N;
	cout << Fib(N) << "\n";
	return 0;
}
```

Результат виконання першої програми:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/13%20Lab%202%20Sem%20%201%20Course%20%20-%20Recurs%20n2.png"/>
</p>

Результат виконання другої програми:
<p align='center'>
    <img src="https://github.com/Nakama3942/StudentProjectOnBMTP/blob/main/Assets/13%20Lab%202%20Sem%20%201%20Course%20%20-%20Recurs%20n3.png"/>
</p>

Давайте перевіримо, як добре працюють наші програми. Відразу можна відмітити правильну роботу другої програми, однак число 50 вона вже не смогла порахувати. Це може бути через те, що змінна int може зберігати число не більше 2 з хвостиком мільйонів, а при розрахунку числа “30” ми вже у відповідь отримуємо число, розміром майже з мільйон. Інших питань по цій програмі немає. Беремося за перевірку першої програми. З формул “s1 = s1 * k + s2” та “s2 = s2 * k”, а також “s1 = 0”, “s2 = 1” ми бачимо, що після першого розрахунку ці змінні зміняться місцями (стануть s1 = 1, а s2 = 0), й після цього s2 тепер буде завжди дорівнювати нулю, так як постійне перемноження самого себе, коли ти дорівнюєш нулю, на будь-яке число буде завжди дорівнювати самому собі. Незалежно від заданого користувачем значення n (окрім від’ємних значень) буде завжди повертатись “1 на 0”, оскільки у функції впринципі не може виконатись оператор “if”, так як 1 не менше 0, а “while” виконується “y” разів (а він дорівнює нулю), то повертається “x”, над яким не проводилось ніяких операцій, і як 1 туди поступила, так вона й повернулася. Нагадаємо, що s2 завжди дорівнюватиме нулю. Коли “k” збільшується до трьох і вище незалежно від значення s1 у функції scdr вона завжди буде ділитися сама на себе, оскільки вказівник на s1 ділиться на “t”, який дорівнює результату функції gcd, а цей результат, як ми вияснили у попередній раз з одиницею, завжди дорівнює вхідному значенню, тобто s1. Отже “t” через функцію gcd дорівнює s1 і вказівник на s1 можна замінити на його значення. Отримаємо з формули *p1 /= t формулу s1 = 1 або s1 = s1 / s1, тому незалежно від значення лічильника, будь то 2, 5, 7, 9, 15, 900, ми завжди будемо отримувати формулу, де це значення ділиться саме на себе й у результаті виходить одиниця. Повернемося у формулу “s1 = s1 * k + s2”: ми виводимо що вона дорівнює “s1 = 1 * k + 0 = k = 1”. Циклічний круг. Тому незалежно від значення користувача результатом завжди буде “1 на 0”, а у разі ввода від’ємного значення не буде виконуватись цикл й будуть виводитись початкові значення до того, як вони на першому крузі зміняться місцями, а саме “0 на 1”. Робимо висновок, що програма теж працює вірно.

Блок-схема першої програми зображена на четвертій ілюстрації, а другої на п’ятій.

Блок-схеми до програм писались після математичного аналізу, тому рекурсія у блок-схемі написана не так сильно схожою на сам код. Я частину скоротив, оскільки й так було відомо, що це й буде результатом.

### Висновок

Ми навчились викликати функцію з неї самої або через інші функції.

[Ссылка на методичку и готовые программы](https://drive.google.com/drive/folders/1PV8jDpIgWir5BGzCe4zsY_rg_VP2Rnyd?usp=sharing)
